library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity arbiterr is
  Port (
        prio : in std_logic_vector(9 downto 0);
        req : in std_logic_vector(9 downto 0);
        grnt : out std_logic_vector(9 downto 0):= "0000000000";
        chk : out std_logic_vector(9 downto 0):=  "0000000000"  );
end arbiterr;

architecture Behavioral of arbiterr is
-- type comp is array (0 to 8) of std_logic_vector(0 downto 1); 
  signal comp1: std_logic_vector(0 downto 1); 
  signal comp2: std_logic_vector(0 downto 1);
  signal comp3: std_logic_vector(0 downto 1);
  signal comp4: std_logic_vector(0 downto 1);
  signal comp5: std_logic_vector(0 downto 1);
  signal comp6: std_logic_vector(0 downto 1);
  signal comp7: std_logic_vector(0 downto 1);
  signal comp8: std_logic_vector(0 downto 1);
 signal compa: std_logic_vector(8 downto 0);  
  signal request : std_logic;
  signal szb : std_logic_vector(17 downto 0);
  signal st_and : std_logic_vector(29 downto 0);
  signal orgate: std_logic_vector(7 downto 0);
  signal grant : std_logic_vector(9 downto 0) := "0000000000";   
  component bl is
    Port (
    I0 : in std_logic;
    I1 : in std_logic;
    s : in std_logic;
    z : out std_logic;
    opt : in std_logic  );
  end component;
  component comparator is
    Port ( a : in std_logic;
           b : in std_logic;
           p  : in std_logic;
           q : in std_logic;
           op : out std_logic);
  end component;
  component and1 is
    Port (a : in std_logic;
          b : in std_logic;
          opt : in std_logic;
          output: out std_logic );
  end component;
begin
 request <= req(9) and req(8) and req(7) and req(6) and req(5) and req(4) and req(3) and 
            req(2) and req(1) and req(0);
 Req0: bl port map(I0 => '1', I1 => req(0), s => request, z => szb(0), opt => '0'); chk(0)<= szb(8);  
 Req1: bl port map(I0 => '1', I1 => req(1), s => request, z => szb(1), opt => '0');  
 Req2: bl port map(I0 => '1', I1 => req(2), s => request, z => szb(2), opt => '0');
 Req3: bl port map(I0 => '1', I1 => req(3), s => request, z => szb(3), opt => '0');
 Req4: bl port map(I0 => '1', I1 => req(4), s => request, z => szb(4), opt => '0');
 Req5: bl port map(I0 => '1', I1 => req(5), s => request, z => szb(5), opt => '0');        
 Req6: bl port map(I0 => '1', I1 => req(6), s => request, z => szb(6), opt => '0');  
 Req7: bl port map(I0 => '1', I1 => req(7), s => request, z => szb(7), opt => '0');
 Req8: bl port map(I0 => '1', I1 => req(8), s => request, z => szb(8), opt => '0');
 Req9: bl port map(I0 => '1', I1 => req(9), s => request, z => szb(9), opt => '0');  
 com0 : comparator port map (a=>prio(0),b=>prio(1),p=>szb(0),q=>szb(1),op=>compa(0));chk(1)<= compa(1); 
 com1 : comparator port map (a=>prio(2),b=>prio(3),p=>szb(2),q=>szb(3),op=>compa(1));     
 com2 : comparator port map (a=>prio(4),b=>prio(5),p=>szb(4),q=>szb(5),op=>compa(2));
 com3 : comparator port map (a=>prio(6),b=>prio(7),p=>szb(6),q=>szb(7),op=>compa(3)); 
 com4 : comparator port map (a=>prio(8),b=>prio(9),p=>szb(8),q=>szb(9),op=>compa(4)); 
 and_1: and1 port map (a=>compa(0) ,b=>szb(0), opt=>'0' , output=> st_and(0)); chk(2)<= st_and(8);
 and_2: and1 port map (a=>compa(0) ,b=>szb(1), opt=>'1' , output=> st_and(1)); 
 and_3: and1 port map (a=>compa(1) ,b=>szb(2), opt=>'0' , output=> st_and(2));
 and_4: and1 port map (a=>compa(1) ,b=>szb(3), opt=>'1' , output=> st_and(3));
 and_5: and1 port map (a=>compa(2) ,b=>szb(4), opt=>'0' , output=> st_and(4));
 and_6: and1 port map (a=>compa(2) ,b=>szb(5), opt=>'1' , output=> st_and(5));
 and_7: and1 port map (a=>compa(3) ,b=>szb(6), opt=>'0' , output=> st_and(6));
 and_8: and1 port map (a=>compa(3) ,b=>szb(7), opt=>'1' , output=> st_and(7));
 and_9: and1 port map (a=>compa(4) ,b=>szb(8), opt=>'0' , output=> st_and(8));
 and_10: and1 port map (a=>compa(4) ,b=>szb(9), opt=>'1' , output=> st_and(9));
 Req10: bl port map(I0 => prio(0), I1 => prio(1), s => compa(0), z =>szb(10), opt => '1'); 
 Req11: bl port map(I0 => prio(2), I1 => prio(3), s => compa(1), z =>szb(11), opt => '1');  chk(3)<= szb(11);
 Req12: bl port map(I0 => prio(4), I1 => prio(5), s => compa(2), z =>szb(12), opt => '1');  
 Req13: bl port map(I0 => prio(6), I1 => prio(7), s => compa(3), z =>szb(13), opt => '1');  
 Req14: bl port map(I0 => prio(8), I1 => prio(9), s => compa(4), z =>szb(14), opt => '1');  
 orgate(0) <= st_and(0) or st_and(1);
 orgate(1) <= st_and(2) or st_and(3); chk(4)<= orgate(1);
 orgate(2) <= st_and(4) or st_and(5);
 orgate(3) <= st_and(6) or st_and(7);
 orgate(4) <= st_and(8) or st_and(9); 
 com5 : comparator port map (a=>szb(10),b=>szb(11),p=>orgate(0),q=>orgate(1),op=>compa(5));chk(5)<= compa(5);
 com6 : comparator port map (a=>szb(12),b=>szb(13),p=>orgate(2),q=>orgate(3),op=>compa(6));
 and_11: and1 port map (a=>st_and(0) ,b=>compa(5), opt=>'0' , output=> st_and(10));
 and_12: and1 port map (a=>st_and(1) ,b=>compa(5), opt=>'0' , output=> st_and(11));
 and_13: and1 port map (a=>compa(5) ,b=>st_and(2), opt=>'1' , output=> st_and(12));chk(6)<= st_and(12);
 and_14: and1 port map (a=>compa(5) ,b=>st_and(3), opt=>'1' , output=> st_and(13));
 and_15: and1 port map (a=>st_and(4) ,b=>compa(6), opt=>'0' , output=> st_and(14));
 and_16: and1 port map (a=>st_and(6) ,b=>compa(6), opt=>'0' , output=> st_and(15));
 and_17: and1 port map (a=>compa(6) ,b=>st_and(7), opt=>'1' , output=> st_and(16));
 and_18: and1 port map (a=>compa(6) ,b=>st_and(8), opt=>'1' , output=> st_and(17));
 Req15: bl port map(I0 => szb(10), I1 => szb(11), s => compa(5), z =>szb(15), opt => '1'); chk(7)<= szb(15);
 Req16: bl port map(I0 => szb(12), I1 => szb(13), s => compa(6), z =>szb(16), opt => '1');  
 orgate(5) <= st_and(14) or  st_and(15) or  st_and(16) or  st_and(17); 
 com7 : comparator port map (a=>szb(14),b=>szb(16),p=>orgate(5),q=>orgate(4),op=>compa(7));
 and_19: and1 port map (a=>compa(7) ,b=>st_and(14), opt=>'0' , output=> st_and(18));
 and_20: and1 port map (a=>compa(7) ,b=>st_and(15), opt=>'0' , output=> st_and(19));
 and_21: and1 port map (a=>compa(7) ,b=>st_and(16), opt=>'0' , output=> st_and(20));
 and_22: and1 port map (a=>compa(7) ,b=>st_and(17), opt=>'0' , output=> st_and(21));
 and_23: and1 port map (a=>compa(7) ,b=>st_and(8), opt=>'1' , output=> st_and(22));
 and_24: and1 port map (a=>compa(7) ,b=>st_and(9), opt=>'1' , output=> st_and(23));
 orgate(6) <=  st_and(18) or st_and(19) or st_and(20) or st_and(21) or st_and(22) or st_and(23);
 orgate(7) <=  st_and(10) or st_and(11) or st_and(12) or st_and(13);
 Req17: bl port map(I0 => szb(14), I1 => szb(16), s => compa(7), z =>szb(17), opt => '1');   
 com8 : comparator port map (a=>szb(15),b=>szb(17),p=>orgate(7),q=>orgate(6),op=>compa(8)); chk(8)<= compa(8);    
 and_25: and1 port map (a=>compa(8) ,b=>st_and(10), opt=>'0' , output=> grant(0));
 and_26: and1 port map (a=>compa(8) ,b=>st_and(11), opt=>'0' , output=> grant(1));
 and_27: and1 port map (a=>compa(8) ,b=>st_and(12), opt=>'0' , output=> grant(2)); chk(9)<= st_and(12);
 and_28: and1 port map (a=>compa(8) ,b=>st_and(13), opt=>'0' , output=> grant(3));
 --and_29: and1 port map (a=>compa(8) ,b=>st_and(1), opt=>'0' , output=> grnt(4));
 and_30: and1 port map (a=>compa(8) ,b=>st_and(18), opt=>'1' , output=> grant(4));
 and_31: and1 port map (a=>compa(8) ,b=>st_and(19), opt=>'1' , output=> grant(5));
 and_32: and1 port map (a=>compa(8) ,b=>st_and(20), opt=>'1' , output=> grant(6));
 and_33: and1 port map (a=>compa(8) ,b=>st_and(21), opt=>'1' , output=> grant(7));
 and_34: and1 port map (a=>compa(8) ,b=>st_and(22), opt=>'1' , output=> grant(8));
 and_35: and1 port map (a=>compa(8) ,b=>st_and(23), opt=>'1' , output=> grant(9));
  grnt <= grant;
  end Behavioral;
